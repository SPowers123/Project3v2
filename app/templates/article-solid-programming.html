{% extends "base.html" %}
{% block title %}Solid Programming{% endblock %}
{% block head %}
    {{ super() }}
    <style type="text/css">
        .important { color: #336699; }
    </style>
{% endblock %}
{% block content %}
<div class="container">
    <div class="row justify-content-between">
        <div class="col">
            <div class="mt-5">
                <h1>Tools: Docker</h1>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-3 content-col rounded mt-2">
            <p class="lead">Content<br>
                <a href="#solid">SOLID principles and calculators</a><br>
            </p>   
        </div>
    </div>
    <div class="row">
        <div class="col">
            <h1 id="solid">What does solid stand for and where is each letter shown</h1>
            <p class="lead">  SOLID is actually an acronym for the first five principles of object oriented design. These are the : S-ingle responsibility Principle, O-pen closed Principle, 
            L-iskov Substitution Principle, I-nterface Segregation Principle, and the D-ependency Inversion Principle." 

</p>

            <h2>Single-responsibility Principle (SRP)</h2>
            
            <p class="lead">Single-responsibility Principle (SRP) states:
            A class should have one and only one reason to change, meaning that a class should have only one job. We see this in simple methods such as addition only adding two variables 
            and even complex methods such as sample_mean keeping scope in check and only returning the final division statement after all the other work is done so the method can be easily called upon. 
 </p>
            
            <h2>Open-closed Principle</h2>
            
            <p class="lead">The next principle, Open-closed Principle, entails that objects or entities should be open for extension but closed for modification. The Mean method shows up once again in this regard.
            Throughout the program there’s not a single line of code CHANGING what the object created is and does, only the samplemean.py file EXTENDING what the object entails and adding on to its functions </p>
            
            <h2>Liskov Substitution Principle</h2>
            
            <p class="lead">After that the Liskov Substitution Principle states that every subclass or derived class should be substitutable for their base or parent class. The getsample method helps us understand this principle.
            When called in the samplemean file, it takes the same variables as it originally did in the get sample file which are data and sample_size. This ensures that the method complies with the same rules of the return values 
            of the superclass. Because of this this subclass can substitute for its superclass thus abiding by this principle. 
 </p>
            
            <h2>Interface segregation principle</h2>
            
            <p class="lead">A client should never be forced to implement an interface that it doesn’t use, or clients shouldn’t be forced to depend on methods they do not use. 
            We can see this when a user wants to find the sample mean they don’t have to use the subtraction method as subtraction isn’t used normally in sample mean calculations
            so variables and methods from a class about subtraction shouldn’t be needed either.  </p>
            
            <h2>Dependency inversion principle</h2>
            
            <p class="lead">Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but they should depend on abstractions.
            The <kbd>getSample</kbd> method is a shining example of this as it wraps information while not entangling higher and lower level modules in the wrong way. 
 </p>
            
            

     </div>
</div>
     
    
    
    
    
    
</div>
{% endblock %}
